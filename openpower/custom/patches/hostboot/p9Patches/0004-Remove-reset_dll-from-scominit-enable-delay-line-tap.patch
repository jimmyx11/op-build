From 270d4c05496356a5bf5982fc2ddb468d76011b22 Mon Sep 17 00:00:00 2001
From: Andre Marin <aamarin@us.ibm.com>
Date: Wed, 12 Jul 2017 09:42:23 -0500
Subject: [PATCH] Remove reset_dll from scominit, enable delay line tap points

reset_dll API was found to be redundant to what already
exists in the initfile per John Bialas.  Removed if
from scominit.  Also included initfile changes that
John made by enabling delay line tap points

Change-Id: Ide517e8dced5176d508dcb352e041e09da206a09
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/43018
Reviewed-by: JACOB L. HARVEY <jlharvey@us.ibm.com>
Reviewed-by: STEPHEN GLANCY <sglancy@us.ibm.com>
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Tested-by: PPE CI <ppe-ci+hostboot@us.ibm.com>
Tested-by: Hostboot CI <hostboot-ci+hostboot@us.ibm.com>
Reviewed-by: Louis Stermole <stermole@us.ibm.com>
Reviewed-by: Matt K. Light <mklight@us.ibm.com>
Reviewed-by: Christian R. Geddes <crgeddes@us.ibm.com>
Reviewed-by: Jennifer A. Stofer <stofer@us.ibm.com>
---
 .../p9/procedures/hwp/initfiles/p9n_ddrphy_scom.C  | 136 ++++++++++++---------
 .../p9/procedures/hwp/memory/lib/phy/ddr_phy.C     |   3 -
 .../chips/p9/procedures/hwp/memory/lib/phy/dp16.C  |  32 -----
 .../hwp/memory/lib/workarounds/dp16_workarounds.H  |  50 --------
 .../xml/attribute_info/chip_ec_attributes.xml      |  57 ++++++++-
 5 files changed, 135 insertions(+), 143 deletions(-)

diff --git a/src/import/chips/p9/procedures/hwp/initfiles/p9n_ddrphy_scom.C b/src/import/chips/p9/procedures/hwp/initfiles/p9n_ddrphy_scom.C
index 2df2100..e6001d4 100644
--- a/src/import/chips/p9/procedures/hwp/initfiles/p9n_ddrphy_scom.C
+++ b/src/import/chips/p9/procedures/hwp/initfiles/p9n_ddrphy_scom.C
@@ -37,6 +37,7 @@ constexpr uint64_t literal_0x6740 = 0x6740;
 constexpr uint64_t literal_0x0402 = 0x0402;
 constexpr uint64_t literal_0x6000 = 0x6000;
 constexpr uint64_t literal_0x4000 = 0x4000;
+constexpr uint64_t literal_0x0006 = 0x0006;
 constexpr uint64_t literal_0x7F7F = 0x7F7F;
 constexpr uint64_t literal_0x0800 = 0x0800;
 constexpr uint64_t literal_0x2020 = 0x2020;
@@ -56,25 +57,17 @@ fapi2::ReturnCode p9n_ddrphy_scom(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& T
         FAPI_TRY(FAPI_ATTR_GET_PRIVILEGED(fapi2::ATTR_EC, TGT1, l_chip_ec));
         fapi2::buffer<uint64_t> l_scom_buffer;
         {
-            FAPI_TRY(fapi2::getScom( TGT0, 0x800000030701103full, l_scom_buffer ));
-
             if (((l_chip_id == 0x5) && (l_chip_ec == 0x10)) )
             {
-                if (( true ))
-                {
-                    l_scom_buffer.insert<48, 16, 48, uint64_t>(literal_0x0120 );
-                }
-            }
+                FAPI_TRY(fapi2::getScom( TGT0, 0x800000030701103full, l_scom_buffer ));
 
-            if (((l_chip_id == 0x5) && (l_chip_ec == 0x20)) || ((l_chip_id == 0x5) && (l_chip_ec == 0x21)) )
-            {
                 if (( true ))
                 {
                     l_scom_buffer.insert<48, 16, 48, uint64_t>(literal_0x0120 );
                 }
-            }
 
-            FAPI_TRY(fapi2::putScom(TGT0, 0x800000030701103full, l_scom_buffer));
+                FAPI_TRY(fapi2::putScom(TGT0, 0x800000030701103full, l_scom_buffer));
+            }
         }
         {
             if (((l_chip_id == 0x5) && (l_chip_ec == 0x10)) )
@@ -225,6 +218,19 @@ fapi2::ReturnCode p9n_ddrphy_scom(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& T
             FAPI_TRY(fapi2::putScom(TGT0, 0x800000750701103full, l_scom_buffer));
         }
         {
+            if (((l_chip_id == 0x5) && (l_chip_ec == 0x20)) || ((l_chip_id == 0x5) && (l_chip_ec == 0x21)) )
+            {
+                FAPI_TRY(fapi2::getScom( TGT0, 0x800000770701103full, l_scom_buffer ));
+
+                if (( true ))
+                {
+                    l_scom_buffer.insert<48, 16, 48, uint64_t>(literal_0x0006 );
+                }
+
+                FAPI_TRY(fapi2::putScom(TGT0, 0x800000770701103full, l_scom_buffer));
+            }
+        }
+        {
             FAPI_TRY(fapi2::getScom( TGT0, 0x800000780701103full, l_scom_buffer ));
 
             if (( true ))
@@ -371,25 +377,17 @@ fapi2::ReturnCode p9n_ddrphy_scom(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& T
             }
         }
         {
-            FAPI_TRY(fapi2::getScom( TGT0, 0x800004030701103full, l_scom_buffer ));
-
             if (((l_chip_id == 0x5) && (l_chip_ec == 0x10)) )
             {
-                if (( true ))
-                {
-                    l_scom_buffer.insert<48, 16, 48, uint64_t>(literal_0x0120 );
-                }
-            }
+                FAPI_TRY(fapi2::getScom( TGT0, 0x800004030701103full, l_scom_buffer ));
 
-            if (((l_chip_id == 0x5) && (l_chip_ec == 0x20)) || ((l_chip_id == 0x5) && (l_chip_ec == 0x21)) )
-            {
                 if (( true ))
                 {
                     l_scom_buffer.insert<48, 16, 48, uint64_t>(literal_0x0120 );
                 }
-            }
 
-            FAPI_TRY(fapi2::putScom(TGT0, 0x800004030701103full, l_scom_buffer));
+                FAPI_TRY(fapi2::putScom(TGT0, 0x800004030701103full, l_scom_buffer));
+            }
         }
         {
             if (((l_chip_id == 0x5) && (l_chip_ec == 0x10)) )
@@ -540,6 +538,19 @@ fapi2::ReturnCode p9n_ddrphy_scom(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& T
             FAPI_TRY(fapi2::putScom(TGT0, 0x800004750701103full, l_scom_buffer));
         }
         {
+            if (((l_chip_id == 0x5) && (l_chip_ec == 0x20)) || ((l_chip_id == 0x5) && (l_chip_ec == 0x21)) )
+            {
+                FAPI_TRY(fapi2::getScom( TGT0, 0x800004770701103full, l_scom_buffer ));
+
+                if (( true ))
+                {
+                    l_scom_buffer.insert<48, 16, 48, uint64_t>(literal_0x0006 );
+                }
+
+                FAPI_TRY(fapi2::putScom(TGT0, 0x800004770701103full, l_scom_buffer));
+            }
+        }
+        {
             FAPI_TRY(fapi2::getScom( TGT0, 0x800004780701103full, l_scom_buffer ));
 
             if (( true ))
@@ -686,25 +697,17 @@ fapi2::ReturnCode p9n_ddrphy_scom(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& T
             }
         }
         {
-            FAPI_TRY(fapi2::getScom( TGT0, 0x800008030701103full, l_scom_buffer ));
-
             if (((l_chip_id == 0x5) && (l_chip_ec == 0x10)) )
             {
-                if (( true ))
-                {
-                    l_scom_buffer.insert<48, 16, 48, uint64_t>(literal_0x0120 );
-                }
-            }
+                FAPI_TRY(fapi2::getScom( TGT0, 0x800008030701103full, l_scom_buffer ));
 
-            if (((l_chip_id == 0x5) && (l_chip_ec == 0x20)) || ((l_chip_id == 0x5) && (l_chip_ec == 0x21)) )
-            {
                 if (( true ))
                 {
                     l_scom_buffer.insert<48, 16, 48, uint64_t>(literal_0x0120 );
                 }
-            }
 
-            FAPI_TRY(fapi2::putScom(TGT0, 0x800008030701103full, l_scom_buffer));
+                FAPI_TRY(fapi2::putScom(TGT0, 0x800008030701103full, l_scom_buffer));
+            }
         }
         {
             if (((l_chip_id == 0x5) && (l_chip_ec == 0x10)) )
@@ -855,6 +858,19 @@ fapi2::ReturnCode p9n_ddrphy_scom(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& T
             FAPI_TRY(fapi2::putScom(TGT0, 0x800008750701103full, l_scom_buffer));
         }
         {
+            if (((l_chip_id == 0x5) && (l_chip_ec == 0x20)) || ((l_chip_id == 0x5) && (l_chip_ec == 0x21)) )
+            {
+                FAPI_TRY(fapi2::getScom( TGT0, 0x800008770701103full, l_scom_buffer ));
+
+                if (( true ))
+                {
+                    l_scom_buffer.insert<48, 16, 48, uint64_t>(literal_0x0006 );
+                }
+
+                FAPI_TRY(fapi2::putScom(TGT0, 0x800008770701103full, l_scom_buffer));
+            }
+        }
+        {
             FAPI_TRY(fapi2::getScom( TGT0, 0x800008780701103full, l_scom_buffer ));
 
             if (( true ))
@@ -1001,25 +1017,17 @@ fapi2::ReturnCode p9n_ddrphy_scom(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& T
             }
         }
         {
-            FAPI_TRY(fapi2::getScom( TGT0, 0x80000c030701103full, l_scom_buffer ));
-
             if (((l_chip_id == 0x5) && (l_chip_ec == 0x10)) )
             {
-                if (( true ))
-                {
-                    l_scom_buffer.insert<48, 16, 48, uint64_t>(literal_0x0120 );
-                }
-            }
+                FAPI_TRY(fapi2::getScom( TGT0, 0x80000c030701103full, l_scom_buffer ));
 
-            if (((l_chip_id == 0x5) && (l_chip_ec == 0x20)) || ((l_chip_id == 0x5) && (l_chip_ec == 0x21)) )
-            {
                 if (( true ))
                 {
                     l_scom_buffer.insert<48, 16, 48, uint64_t>(literal_0x0120 );
                 }
-            }
 
-            FAPI_TRY(fapi2::putScom(TGT0, 0x80000c030701103full, l_scom_buffer));
+                FAPI_TRY(fapi2::putScom(TGT0, 0x80000c030701103full, l_scom_buffer));
+            }
         }
         {
             if (((l_chip_id == 0x5) && (l_chip_ec == 0x10)) )
@@ -1170,6 +1178,19 @@ fapi2::ReturnCode p9n_ddrphy_scom(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& T
             FAPI_TRY(fapi2::putScom(TGT0, 0x80000c750701103full, l_scom_buffer));
         }
         {
+            if (((l_chip_id == 0x5) && (l_chip_ec == 0x20)) || ((l_chip_id == 0x5) && (l_chip_ec == 0x21)) )
+            {
+                FAPI_TRY(fapi2::getScom( TGT0, 0x80000c770701103full, l_scom_buffer ));
+
+                if (( true ))
+                {
+                    l_scom_buffer.insert<48, 16, 48, uint64_t>(literal_0x0006 );
+                }
+
+                FAPI_TRY(fapi2::putScom(TGT0, 0x80000c770701103full, l_scom_buffer));
+            }
+        }
+        {
             FAPI_TRY(fapi2::getScom( TGT0, 0x80000c780701103full, l_scom_buffer ));
 
             if (( true ))
@@ -1316,25 +1337,17 @@ fapi2::ReturnCode p9n_ddrphy_scom(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& T
             }
         }
         {
-            FAPI_TRY(fapi2::getScom( TGT0, 0x800010030701103full, l_scom_buffer ));
-
             if (((l_chip_id == 0x5) && (l_chip_ec == 0x10)) )
             {
-                if (( true ))
-                {
-                    l_scom_buffer.insert<48, 16, 48, uint64_t>(literal_0x0120 );
-                }
-            }
+                FAPI_TRY(fapi2::getScom( TGT0, 0x800010030701103full, l_scom_buffer ));
 
-            if (((l_chip_id == 0x5) && (l_chip_ec == 0x20)) || ((l_chip_id == 0x5) && (l_chip_ec == 0x21)) )
-            {
                 if (( true ))
                 {
                     l_scom_buffer.insert<48, 16, 48, uint64_t>(literal_0x0120 );
                 }
-            }
 
-            FAPI_TRY(fapi2::putScom(TGT0, 0x800010030701103full, l_scom_buffer));
+                FAPI_TRY(fapi2::putScom(TGT0, 0x800010030701103full, l_scom_buffer));
+            }
         }
         {
             if (((l_chip_id == 0x5) && (l_chip_ec == 0x10)) )
@@ -1485,6 +1498,19 @@ fapi2::ReturnCode p9n_ddrphy_scom(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& T
             FAPI_TRY(fapi2::putScom(TGT0, 0x800010750701103full, l_scom_buffer));
         }
         {
+            if (((l_chip_id == 0x5) && (l_chip_ec == 0x20)) || ((l_chip_id == 0x5) && (l_chip_ec == 0x21)) )
+            {
+                FAPI_TRY(fapi2::getScom( TGT0, 0x800010770701103full, l_scom_buffer ));
+
+                if (( true ))
+                {
+                    l_scom_buffer.insert<48, 16, 48, uint64_t>(literal_0x0006 );
+                }
+
+                FAPI_TRY(fapi2::putScom(TGT0, 0x800010770701103full, l_scom_buffer));
+            }
+        }
+        {
             FAPI_TRY(fapi2::getScom( TGT0, 0x800010780701103full, l_scom_buffer ));
 
             if (( true ))
diff --git a/src/import/chips/p9/procedures/hwp/memory/lib/phy/ddr_phy.C b/src/import/chips/p9/procedures/hwp/memory/lib/phy/ddr_phy.C
index 919869a..b2989e9 100644
--- a/src/import/chips/p9/procedures/hwp/memory/lib/phy/ddr_phy.C
+++ b/src/import/chips/p9/procedures/hwp/memory/lib/phy/ddr_phy.C
@@ -777,9 +777,6 @@ fapi2::ReturnCode phy_scominit(const fapi2::Target<TARGET_TYPE_MCBIST>& i_target
         FAPI_TRY( mss::dp16::reset_bad_bits(p) );
 #endif
 
-        // New for Nimbus reset the DLL
-        FAPI_TRY( mss::dp16::reset_dll(p) );
-
         FAPI_TRY( mss::rank::get_rank_pairs(p, l_pairs) );
 
         // Section 5.2.4.8 DP16 Write Clock Enable & Clock Selection on page 301
diff --git a/src/import/chips/p9/procedures/hwp/memory/lib/phy/dp16.C b/src/import/chips/p9/procedures/hwp/memory/lib/phy/dp16.C
index 6eac144..461fe27 100644
--- a/src/import/chips/p9/procedures/hwp/memory/lib/phy/dp16.C
+++ b/src/import/chips/p9/procedures/hwp/memory/lib/phy/dp16.C
@@ -1533,38 +1533,6 @@ fapi_try_exit:
 }
 
 ///
-/// @brief Reset all of the DLL registers - Nimbus only
-/// @param[in] i_target an MCA
-/// @return FAPI2_RC_SUCCESs iff ok
-///
-fapi2::ReturnCode reset_dll( const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target )
-{
-    typedef dp16Traits<TARGET_TYPE_MCA> TT;
-
-    // For DD1.0 we have some workarounds. We send the magic
-    // number in to the work around and it fixes it up as needed.
-    uint64_t l_vreg_cnrtl = mss::workarounds::dp16::vreg_control0(i_target, 0x6740);
-
-    // Magic numbers are from the PHY team (see the ddry phy initfile, too.) They are, in fact,
-    // magic numbers ...
-
-    // TK How about a little broadcast action here? BRS
-    FAPI_TRY( mss::scom_blastah(i_target, TT::DLL_CNFG_REG,        0x0060) );
-    FAPI_TRY( mss::scom_blastah(i_target, TT::DLL_CNTRL_REG,       0x8100) );
-    FAPI_TRY( mss::scom_blastah(i_target, TT::DLL_DAC_LOWER_REG,   0x8000) );
-    FAPI_TRY( mss::scom_blastah(i_target, TT::DLL_DAC_UPPER_REG,   0xffe0) );
-    FAPI_TRY( mss::scom_blastah(i_target, TT::DLL_SLAVE_LOWER_REG, 0x8000) );
-    FAPI_TRY( mss::scom_blastah(i_target, TT::DLL_SLAVE_UPPER_REG, 0xffe0) );
-    FAPI_TRY( mss::scom_blastah(i_target, TT::DLL_EXTRA_REG,       0x2020) );
-    FAPI_TRY( mss::scom_blastah(i_target, TT::DLL_VREG_CNTRL_REG,  l_vreg_cnrtl) );
-    FAPI_TRY( mss::scom_blastah(i_target, TT::DLL_SW_CNTRL_REG,    0x0800) );
-    FAPI_TRY( mss::scom_blastah(i_target, TT::DLL_VREG_COARSE_REG, 0x0402) );
-
-fapi_try_exit:
-    return fapi2::current_err;
-}
-
-///
 /// @brief Configure Read VREF Registers
 /// @param[in] i_target a MCA target
 /// @return FAPI2_RC_SUCCESs iff ok
diff --git a/src/import/chips/p9/procedures/hwp/memory/lib/workarounds/dp16_workarounds.H b/src/import/chips/p9/procedures/hwp/memory/lib/workarounds/dp16_workarounds.H
index 690bad6..8fdb47f 100644
--- a/src/import/chips/p9/procedures/hwp/memory/lib/workarounds/dp16_workarounds.H
+++ b/src/import/chips/p9/procedures/hwp/memory/lib/workarounds/dp16_workarounds.H
@@ -84,56 +84,6 @@ fapi2::ReturnCode rd_dia_config5( const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i
 fapi2::ReturnCode dqsclk_offset( const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target );
 
 ///
-/// @brief DP16 DLL_VREG_CONTROL0
-/// In DD1.0 Nimbus VREG control work arounds are needed
-/// @param[in] port in question - needed to figure out whether to apply the work-around or not
-/// @param[in] i_original_value a value to which we add the workaround bits
-/// @return uint64_t the original value with the bits added
-///
-inline uint64_t vreg_control0( const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
-                               const uint64_t i_original_value )
-{
-
-// Anuwat has asked that we don't enforce this right now.
-#ifdef ANUWAT_SAYS_DONT_DO_THIS_NOW
-
-    fapi2::buffer<uint64_t> l_value(i_original_value);
-    uint8_t l_vccd_override = 0;
-
-    // Check for whether we apply this workaround or not
-    if (! mss::chip_ec_feature_mss_vccd_override(i_target) )
-    {
-        return i_original_value;
-    }
-
-    FAPI_TRY( mss::vccd_override(l_vccd_override) );
-
-    // No VCCD override, don't mess with the DLL's
-    if (fapi2::ENUM_ATTR_MSS_VCCD_OVERRIDE_YES == l_vccd_override)
-    {
-        l_value.insertFromRight<MCA_DDRPHY_DP16_DLL_VREG_CONTROL0_P0_0_01_RXREG_REF_SEL_DC,
-                                MCA_DDRPHY_DP16_DLL_VREG_CONTROL0_P0_0_01_RXREG_REF_SEL_DC_LEN>(0b111);
-    }
-
-    FAPI_INF("vreg_control0 0x%016lx, 0x%016lx", i_original_value, uint64_t(l_value));
-    return l_value;
-
-fapi_try_exit:
-    // Probably bigger problems ...
-    FAPI_ERR("Unable to get vccd_override attribute");
-    fapi2::Assert(false);
-
-    // Not reached
-    return 0;
-
-#else
-
-    return i_original_value;
-
-#endif
-}
-
-///
 /// @brief DP16 VREF DAC override
 /// In DD1.0 Nimbus VREF DAC work arounds are needed
 /// @param[in] i_target the port target for this override
diff --git a/src/import/chips/p9/procedures/xml/attribute_info/chip_ec_attributes.xml b/src/import/chips/p9/procedures/xml/attribute_info/chip_ec_attributes.xml
index 5108455..9b4af94 100644
--- a/src/import/chips/p9/procedures/xml/attribute_info/chip_ec_attributes.xml
+++ b/src/import/chips/p9/procedures/xml/attribute_info/chip_ec_attributes.xml
@@ -1973,7 +1973,7 @@
     <id>ATTR_CHIP_EC_FEATURE_HW408892</id>
     <targetType>TARGET_TYPE_PROC_CHIP</targetType>
     <description>
-      Nimbus DD1.X, DD2.0: Leave at deafult value of DIV_BY_10 
+      Nimbus DD1.X, DD2.0: Leave at deafult value of DIV_BY_10
     </description>
     <chipEcFeature>
       <chip>
@@ -3843,6 +3843,57 @@
   <!-- ******************************************************************** -->
 
   <attribute>
+    <id>ATTR_CHIP_EC_FEATURE_DISABLE_NPU_FREEZE</id>
+    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
+    <description>
+      True if NPU freeze (unit checkstop) should be disabled
+    </description>
+    <chipEcFeature>
+      <chip>
+        <name>ENUM_ATTR_NAME_NIMBUS</name>
+        <ec>
+          <value>0x20</value>
+          <test>LESS_THAN</test>
+        </ec>
+      </chip>
+    </chipEcFeature>
+  </attribute>
+
+  <attribute>
+    <id>ATTR_CHIP_EC_FEATURE_NOT_HW399276</id>
+    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
+    <description>
+      True if chip does not comtain HW399276 defect
+    </description>
+    <chipEcFeature>
+      <chip>
+        <name>ENUM_ATTR_NAME_NIMBUS</name>
+        <ec>
+          <value>0x20</value>
+          <test>LESS_THAN</test>
+        </ec>
+      </chip>
+    </chipEcFeature>
+  </attribute>
+
+<attribute>
+    <id>ATTR_CHIP_EC_FEATURE_HW407064</id>
+    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
+    <description>
+      Enable DP16 delay line tap point for DD2 and beyond
+    </description>
+    <chipEcFeature>
+      <chip>
+        <name>ENUM_ATTR_NAME_NIMBUS</name>
+        <ec>
+          <value>0x20</value>
+          <test>LESS_THAN</test>
+        </ec>
+      </chip>
+    </chipEcFeature>
+  </attribute>
+
+  <attribute>
     <id>ATTR_CHIP_EC_FEATURE_HW368644</id>
     <targetType>TARGET_TYPE_PROC_CHIP</targetType>
     <description>
@@ -4201,8 +4252,8 @@
     <targetType>TARGET_TYPE_PROC_CHIP</targetType>
     <description>
       Returns true if spy name has usage only in P9C.
-      Spy Name of Cumulus; Also used for cumulus only 
-      oscswitch settings. 
+      Spy Name of Cumulus; Also used for cumulus only
+      oscswitch settings.
     </description>
     <chipEcFeature>
       <chip>
-- 
2.9.2.windows.1

